[{"content":"Enhancing Compositional Static Analysis with Dynamic Analysis motivation 静态分析会产生假阳性（误报）的问题，虽然也会产生漏报，但是在程序分析中，一般都是追求sound，而不是complete\n图 1：sound and complete 动态分析无法产生所有测试用例，对程序分析无法做到全覆盖，只能验证测试用例在程序中的正确性。\n为此提出了动态分析和静态分析相结合的发方法，弥补了动态分析不能穷尽所有的分析情况，也弥补了静态分析产生过多的False Positive\nCombining Static and Dynamic Analysis 对一个C程序来说，以链表头插法为例\n1 2 3 void prepend(Node * E, Node * X) { E-\u0026gt;next = X; } procedure summaries $$ { P }\\ C\\ { Q } $$\n如果代码 C 在满足前置条件 P 的时候执行，执行后就保证满足后置条件 Q。\n对上述C程序来说，其过程总结为 $$ { E \\mapsto - \\ast \\mathit{list}(X) }\\ \\texttt{prepend}(E, X)\\ { \\mathit{list}(E) } $$ 前置条件：E 指向一个链表 X，并且 E 需要是某个已分配的内存单元。\n后置条件：函数执行完后，E 成为一个链表，表示 E 现在指向一个包含原有元素和新元素的链表。\n这个过程总结的意义是：如果 prepend(E, X) 函数在 E 指向链表 X 的情况下被调用，那么执行后，E 会指向一个新的链表。\nDynamic Summaries. 在动态分析中，首先将变量映射为值 $$ \\sigma : \\text{Vars} \\to \\text{Vals} $$ 程序的运行是指程序状态的一个序列，记作 𝜎₀𝜎₁𝜎₂···，其中每个 𝜎ᵢ 都是一个具体的程序状态。这个序列属于状态集合 Σ 的一个子集，记作 Σ*。\n为此，生成Dynamic Summaries $$ [\\sigma_I] \\ f(x) \\ [\\sigma_O] $$ Dynamic Summaries描述的是：在程序执行的过程中，给定一个输入状态 $[\\sigma_I]$，经过函数 fff 处理后，会得到一个输出状态 $[\\sigma_O]$。\nexample 对上述C程序不断进行链表头插法 $$ \\begin{aligned}\n[E \\mapsto 6 * X \\mapsto {0,1,2}] , \\text{prepend}(E,X) \u0026amp; [E \\mapsto {6,0,1,2}] \\ [E \\mapsto 7 * X \\mapsto {6,0,1,2}] , \\text{prepend}(E,X) \u0026amp; [E \\mapsto {7,6,0,1,2}] \\ [E \\mapsto 8 * X \\mapsto {7,6,0,1,2}] , \\text{prepend}(E,X) \u0026amp; [E \\mapsto {8,7,6,0,1,2}] \\ [E \\mapsto 9 * X \\mapsto {8,7,6,0,1,2}] , \\text{prepend}(E,X) \u0026amp; [E \\mapsto {9,8,7,6,0,1,2}] \\end{aligned} $$\n1 2 Person p = new Person(); p.setName(\u0026#34;Alice\u0026#34;); $$ \\sigma_I : { p.name \\mapsto \\text{null} } $$\n$$ \\sigma_O : { p.name \\mapsto \\text{\u0026ldquo;Alice\u0026rdquo;} } $$\n$$ \\left[ \\sigma_I \\right] , p.setName(\u0026ldquo;Alice\u0026rdquo;) , \\left[ \\sigma_O \\right] $$\nStatic Summaries 静态总结中，其中，$H_1$ 是前置条件，表示程序 C 执行前程序的状态。\n$H_2$ 是后置条件，表示程序 C 执行后程序的状态。 $$ { H_1 } , C , { H_2 } $$\nSymbolic Heap 符号堆 $H$ 是对程序状态的抽象描述，包含了两个部分：\n等式：表示程序变量之间的关系，等式的形式是 $E = F$，其中 $E$ 和 $F$ 可以是程序变量 $x$ 或其引号形式的变量 $x\u0026rsquo;$，或者是某个值 $v$。 堆谓词：描述动态分配的数据结构（例如链表）。堆谓词用于表示程序的堆内存状态。 等式（Equalities）： 符号堆中的等式表示不同程序变量之间的关系。这些等式可以是以下几种形式：\n程序变量之间的等式：例如，$x = y$ 表示程序中变量 $x$ 和 $y$ 相等。 程序变量与常量之间的等式：例如，$x = 5$ 表示变量 $x$ 的值为常量 5。 程序变量与表达式之间的等式：例如，$x = y + 3$ 表示变量 $x$ 等于 $y$ 加上 3。 这些等式用于描述变量之间的相互关系和赋值规则。等式通常用来捕捉程序的静态数据流。\n堆谓词（Heap Predicates）： 堆谓词描述了程序中动态分配的内存结构，例如链表、树、数组等。堆谓词用于表示堆上的动态数据结构。\n常见的堆谓词包括：\n链表：例如，list(x) 表示堆上存在一个链表，其中 $x$ 是链表的头节点。 树：例如，tree(x) 表示堆上存在一个树结构，其中 $x$ 是树的根节点。 数组：例如，array(x, n) 表示堆上有一个长度为 $n$ 的数组，其起始位置为 $x$。 指针赋值：例如，x ↦ y 表示堆中存在一条从 $x$ 指向 $y$ 的指针。 堆谓词通常用于描述程序中动态分配的对象和数据结构，它们定义了内存布局、对象之间的关系以及内存指针的流动。\nexample 假设有一个链表操作的程序，符号堆可能会用以下方式表示程序状态：\n程序状态 1：假设链表的头节点 $p$ 指向 $x$，$x$ 指向 $y$。这时符号堆可以表示为： $$ { p \\mapsto x, x \\mapsto y } $$ 这表示堆内存中有一个链表，$p$ 是链表的头节点，$x$ 和 $y$ 是后续节点。\n程序状态 2：假设我们调用了 prepend(E, X)，将元素 $E$​ 添加到链表的头部。链表结构应该变化为： $$ { p \\mapsto E, E \\mapsto x, x \\mapsto y } $$ 这时，$E$ 成为新的头节点，原来的 $p$ 仍然指向新头节点 $E$。\n通过符号堆，我们能在不执行程序的情况下，通过分析堆内存的变化来推断程序的行为。\n应该存在一个抽象函数 $\\alpha$ $$ \\boldsymbol{\\alpha} : \\boldsymbol{\\Sigma} \\rightarrow \\mathcal{H} $$ 它将程序运行过程中的**具体状态对（$\\sigma_I, \\sigma_O$）映射到抽象的符号堆（symbolic heap）**形式：\n$\\Sigma$ 是所有具体状态的集合； $\\mathcal{H}$ 是所有符号堆的集合； $[\\sigma_I], f(x), [\\sigma_O]$ 表示：函数 $f$ 在输入状态 $\\sigma_I$ 下运行，结果是输出状态 $\\sigma_O$； ${ \\alpha(\\sigma_I) } f(x) { \\alpha(\\sigma_O) }$ 表示：抽象函数 $\\alpha$ 将具体状态映射为静态规范（Hoare 三元组）中的前置条件和后置条件。 这个映射的目标是：用抽象表示代替具体行为，从而更容易做静态分析。\n1 2 Person p = new Person(); p.name = \u0026#34;Alice\u0026#34;; 现在关注p.name = \u0026quot;Alice\u0026quot;这个行为，其抽象表示为 $$ { p.name = \\text{null} } \\quad p.name = \u0026ldquo;Alice\u0026rdquo; \\quad { p.name = \u0026ldquo;Alice\u0026rdquo; } $$\nThe difference between Dynamic Summaries and Static Summaries Dynamic Summaries $$ [ { p.name \\mapsto \\text{null} } ]\\quad \\text{setName(\u0026ldquo;Alice\u0026rdquo;)}\\quad [ { p.name \\mapsto \\text{\u0026ldquo;Alice\u0026rdquo;} } ] $$ 这表示：“在某次运行中”，当输入状态为 p.name = null 时，调用 setName(\u0026ldquo;Alice\u0026rdquo;) 之后，状态变为 p.name = \u0026ldquo;Alice\u0026rdquo;。\n📌 它只代表这个具体输入下观察到的行为，不保证对所有情况都成立。\nStatic Summaries $$ { p.name = \\text{null} } \\quad \\text{setName(\u0026ldquo;Alice\u0026rdquo;)} \\quad { p.name = \u0026ldquo;Alice\u0026rdquo; } $$ 这表示：“理论上推导出”，只要满足前提 p.name = null，那么 setName(\u0026ldquo;Alice\u0026rdquo;) 一定会把它变成 \u0026ldquo;Alice\u0026rdquo;，无论什么输入数据结构、运行路径如何。\n📌 它适合用在验证和缺陷检测中，比如证明“某个字段在访问前一定初始化”。\n组合分析怎么用？\n先用动态分析生成多个$$[\\sigma_I] \\ f(x) \\ [\\sigma_O]$$； 然后用这些状态对构建函数 $$α(σ)\\alpha(\\sigma)α(σ)$$，将它们抽象为静态总结； 最终提升静态分析器的能力。 如何提升静态分析的准确性\n对于静态分析无法处理的函数 fff，执行动态分析，记录调用时的输入/输出。\n每个函数执行时，我们记录一个三元组： $$ (\\sigma_I, f, \\sigma_O) $$\n$\\sigma_I$：输入状态（如参数值） $f$：函数名 $\\sigma_O$​：输出状态（如返回值） example 1 2 3 4 5 6 7 8 9 10 class Person { String name; } public class Main { public static void main(String[] args) { Person p = new Person(); // 状态 σ₀ p.name = \u0026#34;Alice\u0026#34;; // 执行 setName 动作 } } $$ [ { p.name \\mapsto \\text{null} } ]\\quad setName(\u0026ldquo;Alice\u0026rdquo;)\\quad [ { p.name \\mapsto \\text{\u0026ldquo;Alice\u0026rdquo;} } ] $$\n把具体值“抽象”成逻辑上的描述：使用抽象函数 α\\alphaα 将状态转换为“符号堆”（symbolic heap）： $$ { p.name = v_1 } \\quad setName(\u0026ldquo;Alice\u0026rdquo;) \\quad { p.name = \\text{\u0026ldquo;Alice\u0026rdquo;} } $$ 初始化静态分析结果和未分析的函数集\n1 (SSpecs, 𝑊s, UF) ← SAnalysis(CodeBase, ∅); SAnalysis(CodeBase, ∅)：对代码库 (CodeBase) 执行初始的静态分析，生成静态规格 (SSpecs)、工作集 (𝑊s) 和未分析的函数集 (UF)。 SSpecs：静态分析得到的程序规范。 𝑊s：静态分析所发现的工作集，通常是关于程序中变量和状态的信息。 UF：未分析的函数集，这些函数在第一次静态分析时没有被成功分析。 初始化总工作集\n1 𝑊all ← 𝑊s; 𝑊all：总工作集，最初等于静态分析得到的工作集 𝑊s。这个工作集会随着算法的进行不断累积。 循环直到所有函数都被分析\n1 while UF ≠ ∅ do while UF ≠ ∅ do：循环直到所有的函数都被成功分析为止。UF 是未分析的函数集，直到它为空，说明所有函数都已经通过静态分析处理。 执行动态分析并更新静态规格\n1 2 3 (DUF, 𝑊d) ← DAnalysis(CodeBase, UF); SDSpecs ← αSpec(DUF); (SSpecs, 𝑊′s, U′F) ← SAnalysis(CodeBase, SSpecs ∪ SDSpecs); DAnalysis(CodeBase, UF)：对未分析的函数集 UF 执行动态分析，得到动态分析结果 DUF 和工作集 𝑊d。 αSpec(DUF)：将动态分析的结果 DUF 转换为静态规格 SDSpecs，这是通过抽象映射（α）实现的。这样，动态数据就能以静态方式表达。 SAnalysis(CodeBase, SSpecs ∪ SDSpecs)：对代码库进行第二次静态分析，这次使用了从动态分析中获得的静态规格 SDSpecs 和原有的静态规格 SSpecs。U′F 是这次分析后未能成功分析的函数集。 更新工作集\n1 𝑊all ← 𝑊all ∪ 𝑊d ∪ 𝑊′s; 更新总工作集 𝑊all，将当前动态分析结果 𝑊d 和新的静态分析工作集 𝑊′s 合并到 𝑊all 中。 检查是否收敛\n1 if UF = U′F then break; 检查未分析的函数集 UF 是否等于新的未分析函数集 U′F。如果两者相同，说明没有新的函数需要分析，算法可以结束。如果不同，表示动态分析提供的新信息帮助静态分析处理了新的函数，继续进行下一轮分析。 更新未分析函数集\n1 UF ← U′F; 更新未分析函数集 UF，使其等于当前轮次静态分析后的未分析函数集 U′F，然后进入下一轮分析。 结束循环，返回结果\n1 return 𝑊all; 当 UF 为空时，说明所有函数都已被成功分析，返回更新后的总工作集 𝑊all。 警告集合 $W$\n$ W $ 是所有可以通过静态或动态分析报告的警告集合。这个集合包含了所有类型的警告，比如潜在的错误、未定义的行为、可能的空指针等。\n动态总结的集合$ D[f] $\n$ D[f] $ 是某个函数 $f(x)$ 所有可能的动态总结的集合。一个动态总结是通过动态分析收集的关于函数的运行时行为的信息。例如，函数 $f(x)$ 在不同输入下的输出、执行路径等信息。\n静态分析与动态分析\n静态分析函数 $ SAnalysis $ 的定义如下： $$ SAnalysis : C \\times 2^S \\to 2^S \\times 2^W \\times 2^{FNames} $$ 其中，$ C $ 是待分析的代码库，$ 2^S $ 是函数总结的集合，表示静态分析的输入。输出为新计算出的函数规范集，警告集（即检测到的可能错误）和未分析的函数名集合。\n动态分析函数 $ DAnalysis $ 的定义如下： $$ DAnalysis : C \\times 2^{FNames} \\to 2^D \\times 2^W $$ 其中，$ C $ 是待分析的代码库，$ 2^{FNames} $ 是未分析的函数名集合，输出为动态总结集 $ D_{UF} \\subseteq D[UF] $ 和警告集。\n后续论文证明了上述算法是可中止的且得到的$U_F$是最小的\nDynamic Models Abstraction 动态分析的缺点为，实际运行中观察到的函数输入/输出的动态总结可能是“过于具体”的。对于每个函数，动态分析可以观察并记录成千上万个这样的总结。直接将它们作为静态分析的规范在一般情况下是不可行的。如果一个函数 $f$ 有很多个规范，那么分析 $f$ 的调用者时可能会导致很多分支，从而降低静态分析的效率\n动态分析会记录一个函数 $f$ 在实际运行中可能的输入输出行为集合，也就是： $$ D_f={[\\sigma_I] \\ f(x) \\ [\\sigma_O]} $$\n如果一个函数在不同输入下的行为非常多，比如：\n$f(1) = 2$ $f(2) = 4$ $f(3) = 6$ \u0026hellip; $f(1000) = 2000$ 这些行为都被动态分析记录下来，那么直接使用这些 原始的总结 会导致静态分析中：\n要枚举大量路径（每个 f 的调用点会产生非常多的路径分支）\n为此解决方式为\n对 $D_f$ 进行 概括性总结（abstraction），提取出更紧凑、更概括性的规则，比如将上述 1000 个输入输出总结成：\n当 $x \u0026gt; 0$ 时，$f(x) = x \\times 2$\n即用一条规则表达出多个具体行为。\n在算法1的第五行就是紧凑操作\n就是将多个 $[\\sigma_I] , f(\u0026hellip;) , [\\sigma_O]$的实例转换为一种逻辑上的、规律性的抽象表示。\nAbstract process 我们定义：\n$D$：所有动态规范（dynamic specs）的集合； $S$：所有静态规范（static specs）的集合； $\\top$：表示一个非确定值（non-deterministic value）； 对任意值域 $D$，扩展出 $D^\\top = D \\cup {\\top}$。 接着，我们定义一个抽象函数，用于将一组动态规范抽象成静态规范： $$ α_Spec:2^D→2^S $$ 这个函数 $\\alpha_{\\text{Spec}}$ 的输入是一组动态规范，输出是相应的静态规范集合。\n这个抽象函数是由一系列抽象步骤组合而成的。首先我们定义一个从具体状态到逻辑表达式的抽象函数： $$ \\alpha : \\Sigma \\to H $$ 它将具体状态（如动态执行中的 I/O 值）映射为逻辑函数（逻辑约束），以供静态规范使用。\n具体地定义如下： $$ \\bigwedge_{x \\in \\text{dom}(\\sigma)} x = \\alpha_V(\\sigma(x), 0) $$ 其中：\n$\\sigma$ 是一个具体的状态（例如某一次函数调用的输入或输出）； $\\text{dom}(\\sigma)$ 表示 $\\sigma$ 中所有变量的集合； $\\alpha_V$ 是一个值抽象函数，将具体值抽象为符号/抽象值。 值抽象函数 $\\alpha_V$ $$ αV:Vals×N→Vals^⊤ $$\n这个函数接受两个参数：\n一个是实际值 $v$； 一个是整数 $l$，用于追踪值的嵌套层级（如列表或元组中的嵌套）； 抽象函数定义如下： $$ \\alpha_V(v, l) = \\begin{cases} \\alpha_N(v) \u0026amp; \\text{如果 } v \\in \\mathbb{N} \\quad \\text{（数字）} \\ \\alpha_A(v) \u0026amp; \\text{如果 } v \\in \\mathbb{A} \\quad \\text{（原子）} \\ \\alpha_{\\text{list}}(v, l) \u0026amp; \\text{如果 } v \\in \\text{EL} \\quad \\text{（列表）} \\ \\alpha_{\\text{tuple}}(v, l) \u0026amp; \\text{如果 } v \\in \\text{ET} \\quad \\text{（元组）} \\ \\top \u0026amp; \\text{其他情况} \\end{cases}\n$$\n其中：\n$\\mathbb{N}$ 是 Erlang 中的整数； $\\mathbb{A}$ 是原子（atoms）集合； $\\text{EL}$ 表示列表值； $\\text{ET}$ 表示元组值； $\\top$ 表示“未知”或“非确定”的抽象值。 数值抽象 $\\alpha_N$ 定义如下： $$ \\alpha_N(n) = \\begin{cases} n \u0026amp; \\text{如果 } 0 \\leq n \\leq p \\ \\top \u0026amp; \\text{否则} \\end{cases}\n$$\n也就是说，我们只显式保留前 $p$ 个自然数的值，其余的一律抽象为 $\\top$（即未知）。\n例子 1：数字\n假设我们选择的数字是 $3$，并且定义 $p = 1$（即只跟踪 0 和 1），我们可以通过以下步骤来计算 $\\alpha_V$：\n如果 $v = 3 \\in \\mathbb{N}$，根据定义，数字的抽象函数是 $\\alpha_N$。 因为 $3$ 超出了我们设置的范围（0 到 1），所以 $\\alpha_N(3) = \\top$。 所以，对于 $v = 3$ 和 $p = 1$，$\\alpha_V(3, 1) = \\top$。\n例子 2：数字（在范围内）\n假设我们选择的数字是 $0$，并且依然定义 $p = 1$，我们可以通过以下步骤来计算 $\\alpha_V$：\n如果 $v = 0 \\in \\mathbb{N}$，我们检查 $0$ 是否在 $[0, 1]$ 范围内。 因为 $0$ 在这个范围内，$\\alpha_N(0) = 0$。 所以，对于 $v = 0$ 和 $p = 1$，$\\alpha_V(0, 1) = 0$。\n例子 3：列表\n假设我们选择了一个包含数字的列表，如 $[3, 5]$，并且定义 $l = 1$（表示列表的嵌套层级）。我们可以通过以下步骤来计算 $\\alpha_V$：\n由于 $[3, 5] \\in \\text{EL}$（Erlang 列表），我们使用 $\\alpha_{\\text{list}}(v, l)$ 进行抽象。 假设 $\\alpha_{\\text{list}}$ 采用某种策略来处理列表的嵌套，在这个例子中，它可能返回一个表示该列表的抽象值，或者如果列表中有数字 $3$ 和 $5$，它们的抽象值可能是 $\\top$，因为这两个数字可能会被抽象化为不可知的值。 例如，如果 $\\alpha_{\\text{list}}$ 处理数字时也只跟踪 $0$ 和 $1$，那么它可能返回一个表示该列表抽象信息的结构。\n所以，对于列表 $[3, 5]$ 和嵌套层级 $l = 1$，$\\alpha_V([3, 5], 1)$ 可能会返回某个抽象的表示（例如 $\\top$）。\n例子 4：元组\n假设我们选择了一个元组 {\u0026quot;hello\u0026quot;, 3}，并且定义 $l = 1$（表示元组的嵌套层级）。我们可以通过以下步骤来计算 $\\alpha_V$：\n由于 ${\u0026ldquo;hello\u0026rdquo;, 3} \\in \\text{ET}$（Erlang 元组），我们使用 $\\alpha_{\\text{tuple}}(v, l)$ 进行抽象。 假设 $\\alpha_{\\text{tuple}}$ 对元组中的每个元素（\u0026quot;hello\u0026quot; 和 3）分别进行抽象。 例如，\u0026quot;hello\u0026quot; 是一个原子，可能会被抽象为某个原子的值，而 $3$ 是一个数字，可能会根据我们设置的范围（$p = 1$）被抽象为 $\\top$。\n所以，对于元组 {\u0026quot;hello\u0026quot;, 3} 和嵌套层级 $l = 1$，$\\alpha_V({\u0026ldquo;hello\u0026rdquo;, 3}, 1)$ 可能会返回一个包含原子和抽象数字的结果，例如 ${\u0026ldquo;hello\u0026rdquo;, \\top}$。\nOver-approximation and Under-approximation 定理 4.1 讲述了抽象函数$\\alpha$ 是 sound 的，意思是对每一个状态 Σ$σ∈Σ$，都有 $σ∈γ(α(σ))$，其中 $γ$是一个操作，通常代表某种变换或者约束的应用。\n这意味着应用抽象函数 $\\alpha$ 后的结果总能覆盖原始状态，抽象不会“丢失”信息，因此 sound 确保了抽象的一致性，避免了由于抽象操作而引入的错误。 $$ \\alpha[\\sigma_I] f(x) [\\sigma_O] = {\\sigma_I} f(x) {\\alpha(\\sigma_O)} $$ 这个公式表示在函数 $f(x)$的调用过程中，只对 输出状态 $σ_O$ 进行抽象，而 输入状态 $\\sigma_I $保持不变。这个抽象方法适用于 过度近似（over-approximation）分析，即函数调用后的输出状态是经过抽象处理的。 $$ \\alpha[\\sigma_I] f(x) [\\sigma_O] = {\\alpha(\\sigma_I)} f(x) {\\sigma_O} $$ 这个公式则表示在函数调用前对 输入状态$ sigma_I $进行抽象，而 输出状态$ \\sigma_O$ 保持不变。这种抽象方法在输入状态不确定或不完全时可能有助于减少分析的复杂性，但同样也可能引入错误的分析结果。\n$$ \\alpha[\\sigma_I] f(x) [\\sigma_O] = {\\alpha(\\sigma_I)} f(x) {\\alpha(\\sigma_O)} $$ 这是文章中使用的抽象方法，在 输入状态 $\\sigma_I$和 输出状态 $\\sigma_O $都进行抽象。这种方法可以将输入和输出的动态总结同时抽象化，但会引入较高的误差和潜在的 false positives，因为输入和输出的所有信息都被抽象为近似值。\n关于 Over-approximation 和 Under-approximation\nOver-approximation（过度近似）：对系统的行为进行了“扩展”，即使在某些情况下可能并不完全准确。过度近似的好处是它能确保所有可能的行为都被考虑，但也容易导致误报。 Under-approximation（欠近似）：对系统行为的分析太过严格，遗漏了一些可能的情况。欠近似能避免误报，但可能错过一些实际的行为。 example 𝐷 = { [𝐸 ↦→ 6∗𝑋 ↦→ {0,1,2}] prepend(E,X) [𝐸 ↦→ {6,0,1,2}], [𝐸 ↦→ 7∗𝑋 ↦→ {6,0,1,2}] prepend(E,X) [𝐸 ↦→ {7,6,0,1,2}], [𝐸 ↦→ 8∗𝑋 ↦→ {7,6,0,1,2}] prepend(E,X) [𝐸 ↦→ {8,7,6,0,1,2}], [𝐸 ↦→ 9∗𝑋 ↦→ {8,7,6,0,1,2}] prepend(E,X) [𝐸 ↦→ {9,8,7,6,0,1,2}] }\n对集合D进行采用抽象函数进行处理，设置的范围为（0，1）\n𝛼𝑆𝑝𝑒𝑐(𝐷) = { [𝐸 ↦→ ⊤∗𝑋 ↦→ {0,1,⊤}] prepend(E,X) [𝐸 ↦→ {⊤,0,⊤}], [𝐸 ↦→ ⊤∗𝑋 ↦→ {⊤,0,⊤}] prepend(E,X) [𝐸 ↦→ {⊤,⊤,⊤}], [𝐸 ↦→ ⊤∗𝑋 ↦→ {⊤,⊤,⊤}] prepend(E,X) [𝐸 ↦→ {⊤,⊤,⊤}], [𝐸 ↦→ ⊤∗𝑋 ↦→ {⊤,⊤,⊤}] prepend(E,X) [𝐸 ↦→ {⊤,⊤,⊤}] }\n最后将动态规格映射成静态规格 $$ \\alpha_{Spec}(D) = { { \\alpha(\\sigma_I) } , f(x) , { \\alpha(\\sigma_O) } \\mid [\\sigma_I] f(x) [\\sigma_O] \\in D } ] $$ $D$ 是一堆 动态的规格（执行观测）；\n每一个动态规格都形如：$[\\sigma_I] f(x) [\\sigma_O]$，表示：当输入状态是 $\\sigma_I$，执行 $f(x)$，结果是 $\\sigma_O$；\n对输入输出都做抽象，形成静态规则：${ \\alpha(\\sigma_I) } f(x) { \\alpha(\\sigma_O) }$；\n最终 $\\alpha_{Spec}(D)$ 得到的是这些抽象规格组成的集合。\n","date":"2025-04-19T20:08:46+08:00","permalink":"https://zashuole.github-io.git/p/myfirstblog/","title":"MyFirstBlog"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://zashuole.github-io.git/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://zashuole.github-io.git/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://zashuole.github-io.git/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://zashuole.github-io.git/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://zashuole.github-io.git/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://zashuole.github-io.git/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://zashuole.github-io.git/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://zashuole.github-io.git/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://zashuole.github-io.git/p/emoji-support/","title":"Emoji Support"}]